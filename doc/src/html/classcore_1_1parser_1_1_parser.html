<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PHP Parser for set theory: core\parser\Parser Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">PHP Parser for set theory
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecore.html">core</a></li><li class="navelem"><a class="el" href="namespacecore_1_1parser.html">parser</a></li><li class="navelem"><a class="el" href="classcore_1_1parser_1_1_parser.html">Parser</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="classcore_1_1parser_1_1_parser-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">core\parser\Parser Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aad3f6fcb0bbe85b46a3c1be1ee790c12"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#aad3f6fcb0bbe85b46a3c1be1ee790c12">parse</a> ()</td></tr>
<tr class="separator:aad3f6fcb0bbe85b46a3c1be1ee790c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb4c48b0196dd15215b02e8471ff0e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#aceb4c48b0196dd15215b02e8471ff0e2">__construct</a> ($tokens=[])</td></tr>
<tr class="separator:aceb4c48b0196dd15215b02e8471ff0e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b6c482f43268e60627cac02736f6ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a27b6c482f43268e60627cac02736f6ba">getVars</a> ()</td></tr>
<tr class="separator:a27b6c482f43268e60627cac02736f6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:acf01afb007e49df11644cd3fa2f3800e"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#acf01afb007e49df11644cd3fa2f3800e">getBaseSet</a> ()</td></tr>
<tr class="separator:acf01afb007e49df11644cd3fa2f3800e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710e715bf9bff13aff4ee00aef56c56f"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a710e715bf9bff13aff4ee00aef56c56f">setBaseSet</a> ($set)</td></tr>
<tr class="separator:a710e715bf9bff13aff4ee00aef56c56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ade1938ce53c822c768d554cb405a4fb0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#ade1938ce53c822c768d554cb405a4fb0">statement</a> ()</td></tr>
<tr class="separator:ade1938ce53c822c768d554cb405a4fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a066337e7db3e224852a5940f0b53007b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a066337e7db3e224852a5940f0b53007b">selementofnelementof</a> ()</td></tr>
<tr class="separator:a066337e7db3e224852a5940f0b53007b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed7e1fdca164461554369e4b7541dba2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#aed7e1fdca164461554369e4b7541dba2">wholenumber</a> ()</td></tr>
<tr class="separator:aed7e1fdca164461554369e4b7541dba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fda6ea1b245fec92392a1ce9b01e540"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a8fda6ea1b245fec92392a1ce9b01e540">selementofnelementof_</a> ()</td></tr>
<tr class="separator:a8fda6ea1b245fec92392a1ce9b01e540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d08c6cef17a80cc7a43768c02a93446"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a4d08c6cef17a80cc7a43768c02a93446">setoperationside</a> ()</td></tr>
<tr class="separator:a4d08c6cef17a80cc7a43768c02a93446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7606e946a5c57675bc7b5869918b2f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#ad7606e946a5c57675bc7b5869918b2f4">curliedsetexp</a> ()</td></tr>
<tr class="separator:ad7606e946a5c57675bc7b5869918b2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37445c1669d6b556d2b4bc9f8988d22"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#ae37445c1669d6b556d2b4bc9f8988d22">setexp</a> ()</td></tr>
<tr class="separator:ae37445c1669d6b556d2b4bc9f8988d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122717f7ba66035b4d197af859b64647"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a122717f7ba66035b4d197af859b64647">setexp_</a> ()</td></tr>
<tr class="separator:a122717f7ba66035b4d197af859b64647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f061adac96ad8f3a3ce7138f0ae016"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a92f061adac96ad8f3a3ce7138f0ae016">identifierliteral</a> ()</td></tr>
<tr class="separator:a92f061adac96ad8f3a3ce7138f0ae016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185116d4563770bd5dfe655fefbf0f06"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a185116d4563770bd5dfe655fefbf0f06">setformula</a> ()</td></tr>
<tr class="separator:a185116d4563770bd5dfe655fefbf0f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272bf7b0d36186813bb541b220272248"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a272bf7b0d36186813bb541b220272248">logicalexp</a> ()</td></tr>
<tr class="separator:a272bf7b0d36186813bb541b220272248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2951821cdd1672904a145e99ed1e22b4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a2951821cdd1672904a145e99ed1e22b4">logicalsubexp</a> ()</td></tr>
<tr class="separator:a2951821cdd1672904a145e99ed1e22b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c7e6e9bb5cffb484dca68cff64ab29"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a20c7e6e9bb5cffb484dca68cff64ab29">logicalsubexp_</a> ()</td></tr>
<tr class="separator:a20c7e6e9bb5cffb484dca68cff64ab29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37389f64f0c16ae6a0d1c28682064aa5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a37389f64f0c16ae6a0d1c28682064aa5">functiondefinition</a> ()</td></tr>
<tr class="separator:a37389f64f0c16ae6a0d1c28682064aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997efe0beef5e9df92eac4145a9e0ed8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a997efe0beef5e9df92eac4145a9e0ed8">functiondefinition_</a> ()</td></tr>
<tr class="separator:a997efe0beef5e9df92eac4145a9e0ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80361c023eff82e4d3a0dda6bcca886f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a80361c023eff82e4d3a0dda6bcca886f">divisibilityoperator</a> ()</td></tr>
<tr class="separator:a80361c023eff82e4d3a0dda6bcca886f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d31d74a551327c88299784b580e568"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a92d31d74a551327c88299784b580e568">comparsionoperator</a> ()</td></tr>
<tr class="separator:a92d31d74a551327c88299784b580e568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239e122394251bd7f074ca0c7c61ed10"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a239e122394251bd7f074ca0c7c61ed10">logicalrhs</a> ()</td></tr>
<tr class="separator:a239e122394251bd7f074ca0c7c61ed10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d5d43baa6007a9a7a080bfb9bce4b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#ab9d5d43baa6007a9a7a080bfb9bce4b0">logicalrhs_</a> ()</td></tr>
<tr class="separator:ab9d5d43baa6007a9a7a080bfb9bce4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d6d2ceb1d2f0790aa811411074ea40"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#ae0d6d2ceb1d2f0790aa811411074ea40">logicalrhs__</a> ()</td></tr>
<tr class="separator:ae0d6d2ceb1d2f0790aa811411074ea40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5a50a87e2fce35138ef301b7a5fea7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a7d5a50a87e2fce35138ef301b7a5fea7">logicalexp_</a> ()</td></tr>
<tr class="separator:a7d5a50a87e2fce35138ef301b7a5fea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5595754fe16949310da113aac24dca7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#ab5595754fe16949310da113aac24dca7">logicaloperator</a> ()</td></tr>
<tr class="separator:ab5595754fe16949310da113aac24dca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ababe0339ce03e725dbd6b71679d05243"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#ababe0339ce03e725dbd6b71679d05243">setliteral</a> ()</td></tr>
<tr class="separator:ababe0339ce03e725dbd6b71679d05243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a732c00b2fa3a1ab50e3881e6633cef7c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a732c00b2fa3a1ab50e3881e6633cef7c">setliteral_</a> ()</td></tr>
<tr class="separator:a732c00b2fa3a1ab50e3881e6633cef7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487bcd403678e3c3dbf6dc33feb18bf5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a487bcd403678e3c3dbf6dc33feb18bf5">pointsetliteral</a> ()</td></tr>
<tr class="separator:a487bcd403678e3c3dbf6dc33feb18bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ed61a0c3b0e13ad48d68b6c8e9361f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#af0ed61a0c3b0e13ad48d68b6c8e9361f">pointsetliteral_</a> ()</td></tr>
<tr class="separator:af0ed61a0c3b0e13ad48d68b6c8e9361f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0942888d0b585a1d6f43d83c3c91b5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a9d0942888d0b585a1d6f43d83c3c91b5">sexpr</a> ()</td></tr>
<tr class="separator:a9d0942888d0b585a1d6f43d83c3c91b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e79f344f080d2caa0ba7ef7fdd30868"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a1e79f344f080d2caa0ba7ef7fdd30868">sexpr_</a> ()</td></tr>
<tr class="separator:a1e79f344f080d2caa0ba7ef7fdd30868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59fa27402286c7e0953ea52ff4ea2ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#ae59fa27402286c7e0953ea52ff4ea2ec">stesruisc</a> ()</td></tr>
<tr class="separator:ae59fa27402286c7e0953ea52ff4ea2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c3500bea093fbdadf453c436abc745"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a34c3500bea093fbdadf453c436abc745">trhs</a> ()</td></tr>
<tr class="separator:a34c3500bea093fbdadf453c436abc745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2e002f17f72c7bb46905604c612bd5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a6f2e002f17f72c7bb46905604c612bd5">stesruisc_</a> ()</td></tr>
<tr class="separator:a6f2e002f17f72c7bb46905604c612bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d22db1eb4e9e4a2f7cfdf5ab7e519e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a52d22db1eb4e9e4a2f7cfdf5ab7e519e">stesruisc__</a> ()</td></tr>
<tr class="separator:a52d22db1eb4e9e4a2f7cfdf5ab7e519e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bcf54d74db8522175ef907db98e3348"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a7bcf54d74db8522175ef907db98e3348">uisc</a> ()</td></tr>
<tr class="separator:a7bcf54d74db8522175ef907db98e3348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86577d08bafe6b176b3e6ab45ea7bdf0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a86577d08bafe6b176b3e6ab45ea7bdf0">sofunctioncall</a> ()</td></tr>
<tr class="separator:a86577d08bafe6b176b3e6ab45ea7bdf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114963d3d700b471a8691d261eb8fa7c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a114963d3d700b471a8691d261eb8fa7c">sofunctionname</a> ()</td></tr>
<tr class="separator:a114963d3d700b471a8691d261eb8fa7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6edf7a256f0ac067f820fe2a85460fb4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a6edf7a256f0ac067f820fe2a85460fb4">arguments</a> ()</td></tr>
<tr class="separator:a6edf7a256f0ac067f820fe2a85460fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eab5a9582bb0d64bfb686114d98ae91"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a7eab5a9582bb0d64bfb686114d98ae91">argument</a> ()</td></tr>
<tr class="separator:a7eab5a9582bb0d64bfb686114d98ae91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559ecd991aeb27842a174dc5b3e7b5af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a559ecd991aeb27842a174dc5b3e7b5af">arguments_</a> ()</td></tr>
<tr class="separator:a559ecd991aeb27842a174dc5b3e7b5af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8fe12931745771efd6f4ef18cc1b1c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#ab8fe12931745771efd6f4ef18cc1b1c5">point</a> ()</td></tr>
<tr class="separator:ab8fe12931745771efd6f4ef18cc1b1c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c0f74b2221f06ebe39d4eb637cd03c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a73c0f74b2221f06ebe39d4eb637cd03c">ssimpleexpression</a> ()</td></tr>
<tr class="separator:a73c0f74b2221f06ebe39d4eb637cd03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ca5ab41149a26b504bbb0c8f876ddd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a71ca5ab41149a26b504bbb0c8f876ddd">scardinality</a> ()</td></tr>
<tr class="separator:a71ca5ab41149a26b504bbb0c8f876ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e137f8d34c9b5bcb4abb5e05afcd06"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a92e137f8d34c9b5bcb4abb5e05afcd06">scardinality_</a> ()</td></tr>
<tr class="separator:a92e137f8d34c9b5bcb4abb5e05afcd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f934c0a740531ba07d0f2abb04e4b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#aa2f934c0a740531ba07d0f2abb04e4b2">ssimpleexpression_</a> ()</td></tr>
<tr class="separator:aa2f934c0a740531ba07d0f2abb04e4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab36650a4df29b723f14e7dcfc5f697ac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#ab36650a4df29b723f14e7dcfc5f697ac">simpleoperator</a> ()</td></tr>
<tr class="separator:ab36650a4df29b723f14e7dcfc5f697ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51286ef69ea12470a12f722e01fa0b5c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a51286ef69ea12470a12f722e01fa0b5c">sfunctioncall</a> ()</td></tr>
<tr class="separator:a51286ef69ea12470a12f722e01fa0b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b75f6e4cf9b763a04ef34f0732ff297"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a8b75f6e4cf9b763a04ef34f0732ff297">sfunctionname</a> ()</td></tr>
<tr class="separator:a8b75f6e4cf9b763a04ef34f0732ff297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5582a73ed7005a2f160b0e7544b65b58"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a5582a73ed7005a2f160b0e7544b65b58">getVarsByIds</a> ($ids)</td></tr>
<tr class="separator:a5582a73ed7005a2f160b0e7544b65b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea5232e44dac756c436fb1b6580781c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#acea5232e44dac756c436fb1b6580781c">getFunctionReturnType</a> ($funcname)</td></tr>
<tr class="separator:acea5232e44dac756c436fb1b6580781c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7b72f004a7b4d83bf39011f4631893"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a7b7b72f004a7b4d83bf39011f4631893">getReturnedValueAsReturTypeObject</a> ($result, $funcAsString)</td></tr>
<tr class="separator:a7b7b72f004a7b4d83bf39011f4631893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0865d5abad4e1a5c7c2d7be737c1fe3e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a0865d5abad4e1a5c7c2d7be737c1fe3e">getStringRepresentation</a> ($result)</td></tr>
<tr class="separator:a0865d5abad4e1a5c7c2d7be737c1fe3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18368319bd828b7adac083de94593be"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#af18368319bd828b7adac083de94593be">getErrorMessage</a> ($<a class="el" href="classcore_1_1parser_1_1_parser.html#adf01527b67314922a483882db45a2732">lookahead</a>, $pos, $func, $expected)</td></tr>
<tr class="separator:af18368319bd828b7adac083de94593be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af537c50c7a84ee7b04fe795a2e1e0e76"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#af537c50c7a84ee7b04fe795a2e1e0e76">calculatePosition</a> ()</td></tr>
<tr class="separator:af537c50c7a84ee7b04fe795a2e1e0e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf01527b67314922a483882db45a2732"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#adf01527b67314922a483882db45a2732">lookahead</a> ()</td></tr>
<tr class="separator:adf01527b67314922a483882db45a2732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992577a84f66e4ea370347f33fc7d517"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a992577a84f66e4ea370347f33fc7d517">match</a> ($val)</td></tr>
<tr class="separator:a992577a84f66e4ea370347f33fc7d517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567482791bd0aaeabde7181b8258357d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a567482791bd0aaeabde7181b8258357d">getExpectedForMatch</a> ($value)</td></tr>
<tr class="separator:a567482791bd0aaeabde7181b8258357d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ddedfb52edf77bda6aba0fe0491739"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#ac8ddedfb52edf77bda6aba0fe0491739">getPossibleTokens</a> ($nonterminal)</td></tr>
<tr class="separator:ac8ddedfb52edf77bda6aba0fe0491739"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a0e2fe4b71a9f0a67cacb12ecede5202f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a0e2fe4b71a9f0a67cacb12ecede5202f">$tokens</a></td></tr>
<tr class="separator:a0e2fe4b71a9f0a67cacb12ecede5202f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80478b49417f118ae72e861f64fc83e9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a80478b49417f118ae72e861f64fc83e9">$pos</a></td></tr>
<tr class="separator:a80478b49417f118ae72e861f64fc83e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaafa378124e8802caa9b69de183d2539"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcore_1_1lib_1_1_map.html">Map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#aaafa378124e8802caa9b69de183d2539">$vars</a></td></tr>
<tr class="separator:aaafa378124e8802caa9b69de183d2539"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-attribs" name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a186a72baba94d2d2d24fb26f44b7dc97"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcore_1_1lib_1_1_set.html">Set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1parser_1_1_parser.html#a186a72baba94d2d2d24fb26f44b7dc97">$baseSet</a></td></tr>
<tr class="separator:a186a72baba94d2d2d24fb26f44b7dc97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aceb4c48b0196dd15215b02e8471ff0e2" name="aceb4c48b0196dd15215b02e8471ff0e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceb4c48b0196dd15215b02e8471ff0e2">&#9670;&#160;</a></span>__construct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::__construct </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$tokens</em> = <code>[]</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a new Parser object with a given array of tokens. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">array</td><td class="paramname">$tokens</td><td>An array of tokens to be parsed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7eab5a9582bb0d64bfb686114d98ae91" name="a7eab5a9582bb0d64bfb686114d98ae91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eab5a9582bb0d64bfb686114d98ae91">&#9670;&#160;</a></span>argument()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::argument </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses an argument token and returns its value as a number, a string, or a set. </p><dl class="section return"><dt>Returns</dt><dd>mixed The value of the argument token, depending on the type of expression parsed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the lookahead token is not a valid start of an argument, or if the argument is invalid or undefined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6edf7a256f0ac067f820fe2a85460fb4" name="a6edf7a256f0ac067f820fe2a85460fb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6edf7a256f0ac067f820fe2a85460fb4">&#9670;&#160;</a></span>arguments()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::arguments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses an argument list token and returns its value as an array of numbers, strings, or sets. </p><dl class="section return"><dt>Returns</dt><dd>array The value of the argument list token, containing the arguments separated by commas. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the lookahead token is not a valid start of an argument list, or if the argument is invalid or undefined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a559ecd991aeb27842a174dc5b3e7b5af" name="a559ecd991aeb27842a174dc5b3e7b5af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a559ecd991aeb27842a174dc5b3e7b5af">&#9670;&#160;</a></span>arguments_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::arguments_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses an argument list continuation token and returns its value as a number, a string, a set, or an empty array. </p><dl class="section return"><dt>Returns</dt><dd>mixed The value of the argument list continuation token, depending on the type of expression parsed, or an empty array if no match is found. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the lookahead token is not a valid continuation of an argument list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af537c50c7a84ee7b04fe795a2e1e0e76" name="af537c50c7a84ee7b04fe795a2e1e0e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af537c50c7a84ee7b04fe795a2e1e0e76">&#9670;&#160;</a></span>calculatePosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::calculatePosition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the position of the current token in the input string. </p><dl class="section return"><dt>Returns</dt><dd>int The position of the current token in the input string. </dd></dl>

</div>
</div>
<a id="a92d31d74a551327c88299784b580e568" name="a92d31d74a551327c88299784b580e568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92d31d74a551327c88299784b580e568">&#9670;&#160;</a></span>comparsionoperator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::comparsionoperator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses a comparison operator and returns its value. A comparison operator can be either = (equal), &lt; (less than), &gt; (greater than), &lt;= (less than or equal), or &gt;= (greater than or equal). </p><dl class="section return"><dt>Returns</dt><dd>string|null The value of the comparison operator, which is one of the symbols mentioned above, or null if the lookahead token is not valid. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the lookahead token does not match the expected token. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7606e946a5c57675bc7b5869918b2f4" name="ad7606e946a5c57675bc7b5869918b2f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7606e946a5c57675bc7b5869918b2f4">&#9670;&#160;</a></span>curliedsetexp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::curliedsetexp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses a set literal enclosed by curly braces and returns its value. A set literal consists of a left curly brace, a set expression, and a right curly brace. </p><dl class="section return"><dt>Returns</dt><dd>array|null The value of the set literal, which is an array of elements, or null if the lookahead token is not valid. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the lookahead token does not match the expected token. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80361c023eff82e4d3a0dda6bcca886f" name="a80361c023eff82e4d3a0dda6bcca886f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80361c023eff82e4d3a0dda6bcca886f">&#9670;&#160;</a></span>divisibilityoperator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::divisibilityoperator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses a divisibility operator and returns its value. A divisibility operator can be either ∣ (divides) or ∤ (does not divide). </p><dl class="section return"><dt>Returns</dt><dd>string|null The value of the divisibility operator, which is either "∣" or "∤", or null if the lookahead token is not valid. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the lookahead token does not match the expected token. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37389f64f0c16ae6a0d1c28682064aa5" name="a37389f64f0c16ae6a0d1c28682064aa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37389f64f0c16ae6a0d1c28682064aa5">&#9670;&#160;</a></span>functiondefinition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::functiondefinition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses a function definition and returns an array of user-defined functions. </p><dl class="section return"><dt>Returns</dt><dd>array|null The parsed function definition or null if an error occurs. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If an unexpected token is encountered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a997efe0beef5e9df92eac4145a9e0ed8" name="a997efe0beef5e9df92eac4145a9e0ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a997efe0beef5e9df92eac4145a9e0ed8">&#9670;&#160;</a></span>functiondefinition_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::functiondefinition_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses a function definition after the arrow and returns an array of user-defined functions. </p><dl class="section return"><dt>Returns</dt><dd>array The parsed function definition or an empty array if none is found. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If an unexpected token is encountered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf01afb007e49df11644cd3fa2f3800e" name="acf01afb007e49df11644cd3fa2f3800e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf01afb007e49df11644cd3fa2f3800e">&#9670;&#160;</a></span>getBaseSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static core\parser\Parser::getBaseSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af18368319bd828b7adac083de94593be" name="af18368319bd828b7adac083de94593be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af18368319bd828b7adac083de94593be">&#9670;&#160;</a></span>getErrorMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::getErrorMessage </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$lookahead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$expected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an error message for a given lookahead token, position, function name, and expected tokens. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">array</td><td class="paramname">$lookahead</td><td>The lookahead token that caused the error. </td></tr>
    <tr><td class="paramtype">int</td><td class="paramname">$pos</td><td>The position of the error in the token array. </td></tr>
    <tr><td class="paramtype">string</td><td class="paramname">$func</td><td>The name of the function where the error occurred. </td></tr>
    <tr><td class="paramtype">array</td><td class="paramname">$expected</td><td>The array of expected tokens that would have prevented the error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string The error message that describes the error and the expected tokens. </dd></dl>

</div>
</div>
<a id="a567482791bd0aaeabde7181b8258357d" name="a567482791bd0aaeabde7181b8258357d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a567482791bd0aaeabde7181b8258357d">&#9670;&#160;</a></span>getExpectedForMatch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::getExpectedForMatch </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the expected token for a given value to be matched with the current token. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">string</td><td class="paramname">$value</td><td>The value to be matched with the current token. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array|null The expected token that has the same value as the given value, or null if no such token exists. </dd></dl>

</div>
</div>
<a id="acea5232e44dac756c436fb1b6580781c" name="acea5232e44dac756c436fb1b6580781c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea5232e44dac756c436fb1b6580781c">&#9670;&#160;</a></span>getFunctionReturnType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::getFunctionReturnType </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$funcname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the return type of a given function name as a string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">string</td><td class="paramname">$funcname</td><td>The name of the function to get the return type of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string The return type of the function as a string. </dd></dl>

</div>
</div>
<a id="ac8ddedfb52edf77bda6aba0fe0491739" name="ac8ddedfb52edf77bda6aba0fe0491739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ddedfb52edf77bda6aba0fe0491739">&#9670;&#160;</a></span>getPossibleTokens()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::getPossibleTokens </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$nonterminal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an array of possible tokens for a given nonterminal symbol in the grammar. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">string</td><td class="paramname">$nonterminal</td><td>The name of the nonterminal symbol to get the possible tokens for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array The array of possible tokens that can start or continue the nonterminal symbol, or an empty array if no such symbol exists. </dd></dl>

</div>
</div>
<a id="a7b7b72f004a7b4d83bf39011f4631893" name="a7b7b72f004a7b4d83bf39011f4631893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b7b72f004a7b4d83bf39011f4631893">&#9670;&#160;</a></span>getReturnedValueAsReturTypeObject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::getReturnedValueAsReturTypeObject </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$funcAsString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the returned value of a function call as an object of the same type as the return type of the function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">mixed</td><td class="paramname">$result</td><td>The returned value of the function call. </td></tr>
    <tr><td class="paramtype">string</td><td class="paramname">$funcAsString</td><td>The name of the function as a string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>object The returned value as an object of the same type as the return type of the function. </dd></dl>

</div>
</div>
<a id="a0865d5abad4e1a5c7c2d7be737c1fe3e" name="a0865d5abad4e1a5c7c2d7be737c1fe3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0865d5abad4e1a5c7c2d7be737c1fe3e">&#9670;&#160;</a></span>getStringRepresentation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::getStringRepresentation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the string representation of a given value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">mixed</td><td class="paramname">$result</td><td>The value to be converted to a string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string The string representation of the value, or 'null' if the value is null, or 'true' or 'false' if the value is a boolean. </dd></dl>

</div>
</div>
<a id="a27b6c482f43268e60627cac02736f6ba" name="a27b6c482f43268e60627cac02736f6ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b6c482f43268e60627cac02736f6ba">&#9670;&#160;</a></span>getVars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::getVars </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the Map object that contains the variables and their values. </p><dl class="section return"><dt>Returns</dt><dd>Map The Map object that stores the variables and their values. </dd></dl>

</div>
</div>
<a id="a5582a73ed7005a2f160b0e7544b65b58" name="a5582a73ed7005a2f160b0e7544b65b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5582a73ed7005a2f160b0e7544b65b58">&#9670;&#160;</a></span>getVarsByIds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::getVarsByIds </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$ids</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a92f061adac96ad8f3a3ce7138f0ae016" name="a92f061adac96ad8f3a3ce7138f0ae016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f061adac96ad8f3a3ce7138f0ae016">&#9670;&#160;</a></span>identifierliteral()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::identifierliteral </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses an identifier literal and returns an array of identifiers.</p>
<dl class="section return"><dt>Returns</dt><dd>array The parsed identifier literal or an empty array if none is found. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If an unexpected token is encountered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a272bf7b0d36186813bb541b220272248" name="a272bf7b0d36186813bb541b220272248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272bf7b0d36186813bb541b220272248">&#9670;&#160;</a></span>logicalexp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::logicalexp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses a logical expression and returns a tree of results. A logical expression consists of one or more logical subexpressions connected by logical operators. A logical subexpression can be either a comparison operator followed by a logical right-hand side, or an arrow operator followed by a user-defined function name, a simple operator and a whole number. A logical operator can be either AND, OR, or XOR. </p><dl class="section return"><dt>Returns</dt><dd>array|null A tree of results, where each node is either a logical operator or a logical subexpression, or null if the lookahead token is not valid. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the lookahead token does not match the expected token. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d5a50a87e2fce35138ef301b7a5fea7" name="a7d5a50a87e2fce35138ef301b7a5fea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d5a50a87e2fce35138ef301b7a5fea7">&#9670;&#160;</a></span>logicalexp_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::logicalexp_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses a logical expression_ and returns an array of results. A logical expression_ can be either a logical operator followed by a logical expression, or an empty string. A logical operator can be either AND, OR. </p><dl class="section return"><dt>Returns</dt><dd>array|null An associative array of results, containing the logical operator and the logical expression, or null if the lookahead token is not valid. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the lookahead token does not match the expected token. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5595754fe16949310da113aac24dca7" name="ab5595754fe16949310da113aac24dca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5595754fe16949310da113aac24dca7">&#9670;&#160;</a></span>logicaloperator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::logicaloperator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses a logical operator token and returns its value. A logical operator can be either ∧ (AND) or ∨ (OR). </p><dl class="section return"><dt>Returns</dt><dd>string|null The value of the logical operator token, or null if no match is found. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the lookahead token is not a valid logical operator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a239e122394251bd7f074ca0c7c61ed10" name="a239e122394251bd7f074ca0c7c61ed10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a239e122394251bd7f074ca0c7c61ed10">&#9670;&#160;</a></span>logicalrhs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::logicalrhs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses a logical right-hand side and returns an array of results. A logical right-hand side can be either a whole number followed by a logical right-hand side_, or an identifier followed by a logical right-hand side_. A logical right-hand side_ can contain divisibility operators, arithmetic operators, user-defined functions, and bound functions. </p><dl class="section return"><dt>Returns</dt><dd>array|null An associative array of results, where each key is either 'num' or an identifier and each value is an array of logical conditions, or null if the lookahead token is not valid. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the lookahead token does not match the expected token. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9d5d43baa6007a9a7a080bfb9bce4b0" name="ab9d5d43baa6007a9a7a080bfb9bce4b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d5d43baa6007a9a7a080bfb9bce4b0">&#9670;&#160;</a></span>logicalrhs_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::logicalrhs_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses a logical right-hand side_ and returns an array of results. A logical right-hand side_ can be either a simple operator followed by a logical right-hand side__, or an empty string. A simple operator can be either + (plus), - (minus), * (multiply), or / (divide). </p><dl class="section return"><dt>Returns</dt><dd>array|null An associative array of results, containing the simple operator and the logical right-hand side__, or null if the lookahead token is not valid. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the lookahead token does not match the expected token. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0d6d2ceb1d2f0790aa811411074ea40" name="ae0d6d2ceb1d2f0790aa811411074ea40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d6d2ceb1d2f0790aa811411074ea40">&#9670;&#160;</a></span>logicalrhs__()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::logicalrhs__ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses a logical right-hand side__ and returns an array of results. A logical right-hand side__ can be either a whole number or an identifier. </p><dl class="section return"><dt>Returns</dt><dd>array|null An associative array of results, containing either 'num' or 'id' as the key and the value of the whole number or the identifier as the value, or null if the lookahead token is not valid. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the lookahead token does not match the expected token. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2951821cdd1672904a145e99ed1e22b4" name="a2951821cdd1672904a145e99ed1e22b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2951821cdd1672904a145e99ed1e22b4">&#9670;&#160;</a></span>logicalsubexp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::logicalsubexp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses a logical subexpression and returns an array of results. A logical subexpression can be either a whole number followed by a divisibility operator and an identifier, or an identifier followed by a logical subexpression_, or a logical expression enclosed by parentheses. A divisibility operator can be either DIVIDES or NOTDIVIDES. </p><dl class="section return"><dt>Returns</dt><dd>array|null An associative array of results, where each key is an identifier and each value is an array of divisibility conditions, or null if the lookahead token is not valid. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the lookahead token does not match the expected token. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20c7e6e9bb5cffb484dca68cff64ab29" name="a20c7e6e9bb5cffb484dca68cff64ab29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20c7e6e9bb5cffb484dca68cff64ab29">&#9670;&#160;</a></span>logicalsubexp_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::logicalsubexp_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses a logical subexpression and returns an array of results. A logical subexpression can be either a comparison operator followed by a logical right-hand side, or an arrow operator followed by a user-defined function name, a simple operator and a whole number. </p><dl class="section return"><dt>Returns</dt><dd>array|null An associative array of results, or null if the lookahead token is not valid. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the lookahead token does not match the expected token. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf01527b67314922a483882db45a2732" name="adf01527b67314922a483882db45a2732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf01527b67314922a483882db45a2732">&#9670;&#160;</a></span>lookahead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::lookahead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the current token without consuming it. </p><dl class="section return"><dt>Returns</dt><dd>array The current token in the token array. </dd></dl>

</div>
</div>
<a id="a992577a84f66e4ea370347f33fc7d517" name="a992577a84f66e4ea370347f33fc7d517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a992577a84f66e4ea370347f33fc7d517">&#9670;&#160;</a></span>match()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::match </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Consumes the current token if it matches the given value, or throws an exception otherwise. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">string</td><td class="paramname">$val</td><td>The value to be matched with the current token. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the current token does not match the given value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad3f6fcb0bbe85b46a3c1be1ee790c12" name="aad3f6fcb0bbe85b46a3c1be1ee790c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad3f6fcb0bbe85b46a3c1be1ee790c12">&#9670;&#160;</a></span>parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::parse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8fe12931745771efd6f4ef18cc1b1c5" name="ab8fe12931745771efd6f4ef18cc1b1c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8fe12931745771efd6f4ef18cc1b1c5">&#9670;&#160;</a></span>point()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::point </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses a point token and returns its value as an LPoint object. </p><dl class="section return"><dt>Returns</dt><dd>LPoint The value of the point token, containing the x and y coordinates of the point. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the lookahead token is not a valid start of a point token, or if the syntax is incorrect. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a487bcd403678e3c3dbf6dc33feb18bf5" name="a487bcd403678e3c3dbf6dc33feb18bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a487bcd403678e3c3dbf6dc33feb18bf5">&#9670;&#160;</a></span>pointsetliteral()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::pointsetliteral </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses a point set literal token and returns its value as an array of points. </p><dl class="section return"><dt>Returns</dt><dd>array|null The value of the point set literal token, or null if no match is found. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the lookahead token is not a valid start of a point set literal. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0ed61a0c3b0e13ad48d68b6c8e9361f" name="af0ed61a0c3b0e13ad48d68b6c8e9361f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ed61a0c3b0e13ad48d68b6c8e9361f">&#9670;&#160;</a></span>pointsetliteral_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::pointsetliteral_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses a comma or a right curly brace token and returns the rest of the point set literal value as an array of points. </p><dl class="section return"><dt>Returns</dt><dd>array|null The rest of the point set literal value, or null if no match is found. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the lookahead token is not a valid end of a point set literal. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71ca5ab41149a26b504bbb0c8f876ddd" name="a71ca5ab41149a26b504bbb0c8f876ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ca5ab41149a26b504bbb0c8f876ddd">&#9670;&#160;</a></span>scardinality()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::scardinality </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses a cardinality token and returns its value as a number. </p><dl class="section return"><dt>Returns</dt><dd>mixed The value of the cardinality token, which is the number of elements in the set expression. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the lookahead token is not a valid start of a cardinality token, or if the set expression is invalid or undefined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92e137f8d34c9b5bcb4abb5e05afcd06" name="a92e137f8d34c9b5bcb4abb5e05afcd06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e137f8d34c9b5bcb4abb5e05afcd06">&#9670;&#160;</a></span>scardinality_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::scardinality_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the cardinality of a set expression.</p>
<p>This function parses a set expression and evaluates it using the Functions class. It then returns the cardinality of the resulting set using the cardinality function. The set expression can be either a simple set, an identifier, or a parenthesized expression. The function expects a vertical bar <code>|</code> at the end of the expression. </p><dl class="section return"><dt>Returns</dt><dd>int|null The cardinality of the set expression, or null if there is a syntax error. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If there is a lexical error or an undefined identifier. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a066337e7db3e224852a5940f0b53007b" name="a066337e7db3e224852a5940f0b53007b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a066337e7db3e224852a5940f0b53007b">&#9670;&#160;</a></span>selementofnelementof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::selementofnelementof </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses an element of or not element of expression and returns a boolean value. An element of or not element of expression consists of a whole number followed by an element of or not element of operator and a set. </p><dl class="section return"><dt>Returns</dt><dd>bool|null A boolean value indicating whether the number is an element of or not an element of the set, or null if the lookahead token is not valid. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the lookahead token does not match the expected token. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8fda6ea1b245fec92392a1ce9b01e540" name="a8fda6ea1b245fec92392a1ce9b01e540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fda6ea1b245fec92392a1ce9b01e540">&#9670;&#160;</a></span>selementofnelementof_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::selementofnelementof_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses an element of or not element of operator and a set and returns an array of results. An element of or not element of operator is either ∈ or ∉, and a set is either a set literal, a set identifier. </p><dl class="section return"><dt>Returns</dt><dd>array|null An associative array of results, containing the operator and the set, or null if the lookahead token is not valid. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the lookahead token does not match the expected token. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a710e715bf9bff13aff4ee00aef56c56f" name="a710e715bf9bff13aff4ee00aef56c56f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710e715bf9bff13aff4ee00aef56c56f">&#9670;&#160;</a></span>setBaseSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static core\parser\Parser::setBaseSet </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae37445c1669d6b556d2b4bc9f8988d22" name="ae37445c1669d6b556d2b4bc9f8988d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae37445c1669d6b556d2b4bc9f8988d22">&#9670;&#160;</a></span>setexp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::setexp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses a set expression and returns its value. A set expression can be either a set literal consisting of a comma-separated list of whole numbers, or a point set literal consisting of a comma-separated list of points enclosed by square brackets, or a set formula consisting of a start and end value, an optional filter formula, and a formula to generate the elements. </p><dl class="section return"><dt>Returns</dt><dd>Set|null The value of the set expression, which is an object of the Set class, or null if the lookahead token is not valid. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the lookahead token does not match the expected token. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a122717f7ba66035b4d197af859b64647" name="a122717f7ba66035b4d197af859b64647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a122717f7ba66035b4d197af859b64647">&#9670;&#160;</a></span>setexp_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::setexp_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses a set expression and returns an array of identifiers or a set formula.</p>
<dl class="section return"><dt>Returns</dt><dd>array|null The parsed set expression or null if an error occurs. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If an unexpected token is encountered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a185116d4563770bd5dfe655fefbf0f06" name="a185116d4563770bd5dfe655fefbf0f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a185116d4563770bd5dfe655fefbf0f06">&#9670;&#160;</a></span>setformula()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::setformula </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses a set formula and returns an array of results. A set formula consists of an identifier, a vertical line, and a logical expression that defines the elements of the set. The logical expression can contain comparison operators, arithmetic operators, user-defined functions, and bound functions. </p><dl class="section return"><dt>Returns</dt><dd>array|null An associative array of results, containing the start and end value of the set, the filter formula that checks the element conditions, and the formula that generates the elements, or null if the lookahead token is not valid. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the lookahead token does not match the expected token. </td></tr>
    <tr><td class="paramname">SemanticException</td><td>If the identifier is misspelled or the bound functions are inconsistent in the logical expression. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ababe0339ce03e725dbd6b71679d05243" name="ababe0339ce03e725dbd6b71679d05243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ababe0339ce03e725dbd6b71679d05243">&#9670;&#160;</a></span>setliteral()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::setliteral </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses a set literal token and returns its value as an array of numbers. </p><dl class="section return"><dt>Returns</dt><dd>array|null The value of the set literal token, or null if no match is found. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the lookahead token is not a valid start of a set literal. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a732c00b2fa3a1ab50e3881e6633cef7c" name="a732c00b2fa3a1ab50e3881e6633cef7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a732c00b2fa3a1ab50e3881e6633cef7c">&#9670;&#160;</a></span>setliteral_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::setliteral_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses a comma or a right curly brace token and returns the rest of the set literal value as an array of numbers. </p><dl class="section return"><dt>Returns</dt><dd>array|null The rest of the set literal value, or null if no match is found. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the lookahead token is not a valid end of a set literal. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d08c6cef17a80cc7a43768c02a93446" name="a4d08c6cef17a80cc7a43768c02a93446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d08c6cef17a80cc7a43768c02a93446">&#9670;&#160;</a></span>setoperationside()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::setoperationside </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses a set operation side and returns its value. A set operation side can be either a set literal enclosed by curly braces, or a set identifier that refers to a variable which is either exist or it does not. </p><dl class="section return"><dt>Returns</dt><dd>mixed|null The value of the set operation side, which can be an array of elements, a string, or null if the lookahead token is not valid. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the lookahead token does not match the expected token. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d0942888d0b585a1d6f43d83c3c91b5" name="a9d0942888d0b585a1d6f43d83c3c91b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d0942888d0b585a1d6f43d83c3c91b5">&#9670;&#160;</a></span>sexpr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::sexpr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses a set expression token and returns its value as a set, a point, a boolean, or a string. </p><dl class="section return"><dt>Returns</dt><dd>mixed The value of the set expression token, depending on the type of operation performed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the lookahead token is not a valid start of a set expression, or if the operation is invalid or undefined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e79f344f080d2caa0ba7ef7fdd30868" name="a1e79f344f080d2caa0ba7ef7fdd30868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e79f344f080d2caa0ba7ef7fdd30868">&#9670;&#160;</a></span>sexpr_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::sexpr_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses a set expression continuation token and returns its value as a set, a point, a boolean, a string, or false. </p><dl class="section return"><dt>Returns</dt><dd>mixed The value of the set expression continuation token, depending on the type of operation performed, or false if no match is found. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the lookahead token is not a valid continuation of a set expression. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51286ef69ea12470a12f722e01fa0b5c" name="a51286ef69ea12470a12f722e01fa0b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51286ef69ea12470a12f722e01fa0b5c">&#9670;&#160;</a></span>sfunctioncall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::sfunctioncall </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses a set function call token and returns its value as a string or an image. </p><dl class="section return"><dt>Returns</dt><dd>mixed The value of the set function call token, either a string representing a Venn diagram, or an image representing a point set diagram. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the lookahead token is not a valid start of a set function call, or if the arguments are invalid or undefined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b75f6e4cf9b763a04ef34f0732ff297" name="a8b75f6e4cf9b763a04ef34f0732ff297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b75f6e4cf9b763a04ef34f0732ff297">&#9670;&#160;</a></span>sfunctionname()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::sfunctionname </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses a set function name token and returns its value as a string. </p><dl class="section return"><dt>Returns</dt><dd>string The value of the set function name token, either 'PointSetDiagram' or 'Venn'. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the lookahead token is not a valid set function name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab36650a4df29b723f14e7dcfc5f697ac" name="ab36650a4df29b723f14e7dcfc5f697ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab36650a4df29b723f14e7dcfc5f697ac">&#9670;&#160;</a></span>simpleoperator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::simpleoperator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses a simple operator token and returns its value as a string. </p><dl class="section return"><dt>Returns</dt><dd>string The value of the simple operator token, either '+', '-', '*', or '/'. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the lookahead token is not a valid simple operator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86577d08bafe6b176b3e6ab45ea7bdf0" name="a86577d08bafe6b176b3e6ab45ea7bdf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86577d08bafe6b176b3e6ab45ea7bdf0">&#9670;&#160;</a></span>sofunctioncall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::sofunctioncall </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses a set operation function call token and returns its value as an array. </p><dl class="section return"><dt>Returns</dt><dd>array The value of the set operation function call token, containing the operator, the function name, and the arguments. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the lookahead token is not a valid start of a set operation function call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a114963d3d700b471a8691d261eb8fa7c" name="a114963d3d700b471a8691d261eb8fa7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a114963d3d700b471a8691d261eb8fa7c">&#9670;&#160;</a></span>sofunctionname()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::sofunctionname </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses a set operation function name token and returns its value as a string. </p><dl class="section return"><dt>Returns</dt><dd>string The value of the set operation function name token, either 'add' or 'delete'. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the lookahead token is not a valid set operation function name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73c0f74b2221f06ebe39d4eb637cd03c" name="a73c0f74b2221f06ebe39d4eb637cd03c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73c0f74b2221f06ebe39d4eb637cd03c">&#9670;&#160;</a></span>ssimpleexpression()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::ssimpleexpression </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses a simple expression token and returns its value as a number. </p><dl class="section return"><dt>Returns</dt><dd>number The value of the simple expression token, depending on the type of arithmetic operation performed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the lookahead token is not a valid start of a simple expression, or if the operation is invalid or undefined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2f934c0a740531ba07d0f2abb04e4b2" name="aa2f934c0a740531ba07d0f2abb04e4b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f934c0a740531ba07d0f2abb04e4b2">&#9670;&#160;</a></span>ssimpleexpression_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::ssimpleexpression_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses a simple expression continuation token and returns its value as a number or false. </p><dl class="section return"><dt>Returns</dt><dd>mixed The value of the simple expression continuation token, depending on the type of arithmetic operation performed, or false if no match is found. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the lookahead token is not a valid continuation of a simple expression, or if the operation is invalid or undefined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade1938ce53c822c768d554cb405a4fb0" name="ade1938ce53c822c768d554cb405a4fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade1938ce53c822c768d554cb405a4fb0">&#9670;&#160;</a></span>statement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::statement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses a statement and returns an array of results. A statement can be either an element of, a subset of, or a set expression, or a simple expression, or a function call. </p><dl class="section return"><dt>Returns</dt><dd>array|null An associative array of results, or null if the lookahead token is not valid. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the lookahead token does not match the expected token. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae59fa27402286c7e0953ea52ff4ea2ec" name="ae59fa27402286c7e0953ea52ff4ea2ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae59fa27402286c7e0953ea52ff4ea2ec">&#9670;&#160;</a></span>stesruisc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::stesruisc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses a set expression continuation token and returns its value as a set, a point, a boolean, a string, or an array. </p><dl class="section return"><dt>Returns</dt><dd>mixed The value of the set expression continuation token, depending on the type of operation performed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the lookahead token is not a valid continuation of a set expression, or if the operation is invalid or undefined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f2e002f17f72c7bb46905604c612bd5" name="a6f2e002f17f72c7bb46905604c612bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f2e002f17f72c7bb46905604c612bd5">&#9670;&#160;</a></span>stesruisc_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::stesruisc_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses a set expression continuation token and returns its value as a set, an array, or an empty array. </p><dl class="section return"><dt>Returns</dt><dd>array The value of the set expression continuation token, depending on the type of expression parsed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the lookahead token is not a valid continuation of a set expression, or if the operation is invalid or undefined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52d22db1eb4e9e4a2f7cfdf5ab7e519e" name="a52d22db1eb4e9e4a2f7cfdf5ab7e519e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52d22db1eb4e9e4a2f7cfdf5ab7e519e">&#9670;&#160;</a></span>stesruisc__()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::stesruisc__ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses a set expression continuation token and returns its value as a set or an empty set. </p><dl class="section return"><dt>Returns</dt><dd>array The value of the set expression continuation token, depending on the type of operation performed, or an empty set if no match is found. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the lookahead token is not a valid continuation of a set expression, or if the operation is invalid or undefined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34c3500bea093fbdadf453c436abc745" name="a34c3500bea093fbdadf453c436abc745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34c3500bea093fbdadf453c436abc745">&#9670;&#160;</a></span>trhs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::trhs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses a right-hand side token of a set assignment and returns its value as a set, a point, or an array. </p><dl class="section return"><dt>Returns</dt><dd>mixed The value of the right-hand side token, depending on the type of expression parsed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the lookahead token is not a valid start of a right-hand side expression. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7bcf54d74db8522175ef907db98e3348" name="a7bcf54d74db8522175ef907db98e3348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bcf54d74db8522175ef907db98e3348">&#9670;&#160;</a></span>uisc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::uisc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses a union, intersection, set minus, or complement token and returns its value as an array. </p><dl class="section return"><dt>Returns</dt><dd>array|null The value of the union, intersection, set minus, or complement token, or null if no match is found. </dd></dl>

</div>
</div>
<a id="aed7e1fdca164461554369e4b7541dba2" name="aed7e1fdca164461554369e4b7541dba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed7e1fdca164461554369e4b7541dba2">&#9670;&#160;</a></span>wholenumber()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::wholenumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses a whole number and returns its value. A whole number can be either a positive or a negative integer. </p><dl class="section return"><dt>Returns</dt><dd>int|null The value of the whole number, or null if the lookahead token is not valid. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ParserException</td><td>If the lookahead token does not match the expected token. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a186a72baba94d2d2d24fb26f44b7dc97" name="a186a72baba94d2d2d24fb26f44b7dc97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a186a72baba94d2d2d24fb26f44b7dc97">&#9670;&#160;</a></span>$baseSet</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcore_1_1lib_1_1_set.html">Set</a> core\parser\Parser::$baseSet</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a80478b49417f118ae72e861f64fc83e9" name="a80478b49417f118ae72e861f64fc83e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80478b49417f118ae72e861f64fc83e9">&#9670;&#160;</a></span>$pos</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::$pos</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e2fe4b71a9f0a67cacb12ecede5202f" name="a0e2fe4b71a9f0a67cacb12ecede5202f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e2fe4b71a9f0a67cacb12ecede5202f">&#9670;&#160;</a></span>$tokens</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core\parser\Parser::$tokens</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaafa378124e8802caa9b69de183d2539" name="aaafa378124e8802caa9b69de183d2539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaafa378124e8802caa9b69de183d2539">&#9670;&#160;</a></span>$vars</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcore_1_1lib_1_1_map.html">Map</a> core\parser\Parser::$vars</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/php/core/parser/<a class="el" href="_parser_8php.html">Parser.php</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
